<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2651560750.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-31T14:06:42.214Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2651560750.github.io"/>
    <link rel="self" href="https://2651560750.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://2651560750.github.io/images/avatar.png</logo>
    <icon>https://2651560750.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[数据库学习之权限管理和备份]]></title>
        <id>https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-quan-xian-guan-li-he-bei-fen/</id>
        <link href="https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-quan-xian-guan-li-he-bei-fen/">
        </link>
        <updated>2021-03-31T12:13:54.000Z</updated>
        <content type="html"><![CDATA[<p>#数据库创建用户和权限管理<br>
创建用户 CREATE USER用户名<br>
IDENTIFIED BY '密码'CREATE USER kuangshen IDENTIFIED BY '123456'<br>
--修改密码(修改当前用户密码&gt;<br>
SET PASSwORD = PASSwORD('123456')<br>
--修改密码(修改指定用户密码）<br>
SET PASSWORD FOR kuangshen = PASSWORD('123456')<br>
--重命名RENAME USER原来名字TO新的名字<br>
RENAME USER kuangshen To kuangshen2<br>
--用户授权ALL PRIVILEGES全部的权限，库.表-- ALL PRIVILEGES 除了给别人授权,其他都能够干GRANT ALL PRIVILEGES ON*.*To kuangshen2<br>
—-查询权限<br>
SHOW GRANTS EOR kuangshen2 --查看指定用户的权限SHOW GRANTS FOR root@localhost<br>
-- ROoT用户权限:GRANT ALI PRIVILEGES ON <em>.</em> To 'root' @ 'localhost wITH GRANT OPTIONM<br>
--撤销权限REVOKE哪些权限，在哪个库撤销，给谁撤销<br>
REVOKE ATL PRIVTLEGES ON *.*术FROM kuangshen2<br>
#数据库的备份<br>
为什么要备份:</p>
<ol>
<li>保证重要的数据不丢失</li>
<li>数据转移<br>
MySQL 数据库备份的方式</li>
<li>直接拷贝物理文件</li>
<li>在Sqlyog这种可视化工具中手动导出</li>
<li>使用命令行导出mysqldump命玲行使用<br>
#导出 mysq1dump -h主机 -u用户名-p 密码数据库﹑表名&gt;物理磁盘位置/文件名mysq1dump -hlocalhost -uroot -p123456 school student &gt;D:/a.sq1<br>
mysq1dump -h 主机 -u用户名-p密码 数据库表1表2表3&gt;物理磁盘位置/文件名mysq1dump -h1oca7host -uroot -p123456 school student &gt;D:/b.sq7<br>
mysqldump -h主机-u用户名-p密码数据库&gt;物理磁盘位置/文件名mysq1dump -h1oca1host -uroot -p123456 school &gt;D:/c.sq1<br>
#导入<br>
登录的情况下,切换到指定的数据库# source备份文件<br>
#切换要用的数据库<br>
source d:/a.sq1<br>
mysql -u用户名-p密码 库名&lt;备份文件</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库学习之索引]]></title>
        <id>https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-suo-yin/</id>
        <link href="https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-suo-yin/">
        </link>
        <updated>2021-03-31T11:11:51.000Z</updated>
        <content type="html"><![CDATA[<p>#索引的解释：<br>
MySQL官方对索引的定义为:索引(Index)是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质:索引是数据结构。<br>
在一个表中，主键索引只有一个，而唯一索引可以有多个<br>
#索引的分类：<br>
主键索引<br>
(PRIMARY KEY )<br>
。唯一的标识，主键不可重复，只能有一个列作为主键<br>
唯一索引(UNIQUE KEY)<br>
。避免重复的列出现，唯一索引可以重复，多个列都可以标识位唯一索引<br>
常规索引(KEY/INDEX)<br>
。默认的， index。key关键字来设置<br>
全文索引(FullText)<br>
。在特定的数据库引擎下才有，MylSAM。快速定位数据<br>
#基础语法：<br>
--索引的使用<br>
--1、在创建表的时候给字段增加索引<br>
--2、创建完毕后，增加索引<br>
--显示所有的索引信息<br>
<code>SHOW INDEX FROM student</code><br>
--增加一个全文索引（索引名)列名<br>
<code>ALTER TABLE schoo1.student ADD FULLTEXT INDEX ‘studentName (studentName ');</code><br>
-- EXPLAIN分析sq1执行的状况<br>
<code>EXPLAIN SELECT *FROM student; --非全文索引</code><br>
<code>EXPLAIN SELECT* FROM student wHERE MATCH(studentName)AGAINST('刘');</code></p>
<ul>
<li>id表名_字段名</li>
<li>CREATE INDEX索引名on表(字段)<br>
<code>CREATE INDEX id_app_user_name ON app_user ( 'name `);</code><br>
#测试索引：</li>
</ul>
<pre><code>CREATE TABLE `app_user` (
`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
`name` VARCHAR(50) DEFAULT'' COMMENT'用户昵称',
`email` VARCHAR(50) NOT NULL COMMENT'用户邮箱',
`phone` VARCHAR(20) DEFAULT'' COMMENT'手机号',
`gender` TINYINT(4) UNSIGNED DEFAULT '0'COMMENT '性别（0：男;1:女）',
`password` VARCHAR(100) NOT NULL COMMENT '密码',
`age` TINYINT(4) DEFAULT'0'  COMMENT '年龄',
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT = 'app用户表'


-- 插入100万数据.
DELIMITER $$
-- 写函数之前必须要写，标志
CREATE FUNCTION mock_data ()
RETURNS INT DETERMINISTIC
BEGIN
	DECLARE num INT DEFAULT 1000000;
	DECLARE i INT DEFAULT 0;
	WHILE i&lt;num DO
		INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUES(CONCAT('用户',i),'19224305@qq.com','123456789',FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100));
		SET i=i+1;
	END WHILE;
	RETURN i;
END;
SELECT mock_data() -- 执行此函数 生成一百万条数据
SELECT * FROM app_user WHERE name='用户999999'
CREATE INDEX id_app_user_name ON app_user ( `name`);
SELECT * FROM app_user WHERE name='用户999999'
</code></pre>
<p>#索引的原则：<br>
·索引不是越多越好<br>
·不要对进程变动数据加索引<br>
·小数据量的表不需要加索引<br>
·索引一般加在常用来查询的字段上!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程同步机制（重点加难点）]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-tong-bu-ji-zhi-chong-dian-jia-nan-dian/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-tong-bu-ji-zhi-chong-dian-jia-nan-dian/">
        </link>
        <updated>2021-03-30T12:54:39.000Z</updated>
        <content type="html"><![CDATA[<p>package com.deng.pojo1;<br>
//守护线程随着用户线程的结束而结束<br>
public class TestDaemon {<br>
public static void main(String[] args) {<br>
God god=new God();<br>
You you=new You();<br>
Thread thread=new Thread(god);<br>
thread.setDaemon(true);<br>
thread.start();//上帝守护线程启动<br>
new Thread(you).start();//用户线程启动<br>
}<br>
}<br>
class You implements Runnable{</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 36500; i++) {
        System.out.println(&quot;祝你一生都活的开开心心&quot;);
    }
    System.out.println(&quot;========goodbye,this,world======&quot;);
}
</code></pre>
<p>}<br>
class God implements  Runnable{</p>
<pre><code>@Override
public void run() {
    while (true)
    {
        System.out.println(&quot;上帝一直守护着你&quot;);
    }
}
</code></pre>
<p>}<br>
<img src="https://2651560750.github.io/post-images/1617111080184.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之守护线程]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-shou-hu-xian-cheng/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-shou-hu-xian-cheng/">
        </link>
        <updated>2021-03-30T12:24:56.000Z</updated>
        <content type="html"><![CDATA[<p>#守护线程的定义<br>
线程分为用户线程和守护线程<br>
虚拟机必须确保用户线程执行完毕<br>
虚拟机不用等待守护线程执行完毕<br>
如,后台记录操作日志,监控内存,垃圾回收等待</p>
<pre><code>package com.deng.pojo1;
//守护线程随着用户线程的结束而结束
public class TestDaemon {
    public static void main(String[] args) {
        God god=new God();
        You you=new You();
        Thread thread=new Thread(god);
              thread.setDaemon(true);
              thread.start();//上帝守护线程启动
              new Thread(you).start();//用户线程启动
    }
}
class You implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i &lt; 36500; i++) {
            System.out.println(&quot;祝你一生都活的开开心心&quot;);
        }
        System.out.println(&quot;========goodbye,this,world======&quot;);
    }
}
class God implements  Runnable{

    @Override
    public void run() {
        while (true)
        {
            System.out.println(&quot;上帝一直守护着你&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程的优先级]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-de-you-xian-ji/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-de-you-xian-ji/">
        </link>
        <updated>2021-03-30T12:08:20.000Z</updated>
        <content type="html"><![CDATA[<p>#优先级的概念<br>
Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。<br>
线程的优先级用数字表示，范围从1~10.<br>
Thread.MIN_PRIORITY=1;<br>
Thread.MAX_PRIORITY = 10;Thread.NORM_PRIORITY = 5;使用以下方式改变或获取优先级<br>
getPriority() . setPriority(int xxx)<br>
#代码示范</p>
<pre><code>package com.deng.pojo1;

public class TestPriority {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());
        Mypriority mypriority=new Mypriority();
        Thread t1=new Thread(mypriority);
        Thread t2=new Thread(mypriority);
        Thread t3=new Thread(mypriority);
        Thread t4=new Thread(mypriority);
        Thread t5=new Thread(mypriority);
        t1.start();

        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        t4.setPriority(8);
        t4.start();

        t5.setPriority(Thread.MAX_PRIORITY);
        t5.start();

    }
}
class Mypriority implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之观测线程状态]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-guan-ce-xian-cheng-zhuang-tai/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-guan-ce-xian-cheng-zhuang-tai/">
        </link>
        <updated>2021-03-30T11:48:42.000Z</updated>
        <content type="html"><![CDATA[<p>#实现五种状态的代码</p>
<pre><code>package com.deng.pojo1;

public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread=new Thread(()-&gt;{
            for (int i = 0; i &lt; 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;////////&quot;);
        });
       Thread.State state=thread.getState();
        System.out.println(state);
        thread.start();
        state =thread.getState();
        System.out.println(state);
        while (state!=Thread.State.TERMINATED)
        {
            Thread.sleep(100);
            state=thread.getState();
            System.out.println(state);
        }
    }
}
</code></pre>
<p>#运行结果</p>
<pre><code>NEW
RUNNABLE
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
RUNNABLE
////////
TERMINATED
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之强制执行]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-qiang-zhi-zhi-xing/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-qiang-zhi-zhi-xing/">
        </link>
        <updated>2021-03-30T11:38:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code>package com.deng.pojo1;

public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;线程VIP来了&quot;+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin=new TestJoin();
        Thread thread=new Thread(testJoin);
        thread.start();
        for (int i = 0; i &lt; 500; i++) {
            if(i==200)
            {
                thread.join();
            }
            System.out.println(&quot;main方法执行&quot;+i);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程礼让]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-li-rang/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-li-rang/">
        </link>
        <updated>2021-03-30T11:22:29.000Z</updated>
        <content type="html"><![CDATA[<p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>
将线程从运行状态转为就绪状态<br>
让cpu重新调度，礼让不一定成功!看CPU心情</p>
<pre><code>package com.deng.pojo1;

public class TestYied {
    public static void main(String[] args) {
      Myyield myyield=new Myyield();
      new Thread(myyield,&quot;A&quot;).start();
      new Thread(myyield,&quot;B&quot;).start();
    }
}
class Myyield implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程休眠]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-xiu-mian/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-xiu-mian/">
        </link>
        <updated>2021-03-30T11:00:52.000Z</updated>
        <content type="html"><![CDATA[<p>#模仿网络延迟和获取当前时间</p>
<pre><code>package com.deng.pojo1;

import com.deng.pojo.TestThread5;
//模拟网络延迟：放大问题的发生性
public class TestSleep implements Runnable{
    private int tickeNums=10;
    @Override
    public void run()
    {
        while (true)
        {
            if (tickeNums&lt;=0)
            {
                break;
            }
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+tickeNums--+&quot;张票&quot;);
        }
    }


    public static void main(String[] args) {
        TestThread5 t1=new TestThread5();
        new Thread(t1,&quot;邓贝&quot;).start();
        new Thread(t1,&quot;黄哲浩&quot;).start();
        new Thread(t1,&quot;岁东航&quot;).start();
    }
}
</code></pre>
<pre><code>package com.deng.pojo1;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TestSleep02 {
    public static void main(String[] args) {
//tendown();
//        打印系统当前时间
        Date starttime=new Date(System.currentTimeMillis());//获取当前时间
        while (true)
        {
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(starttime));
                starttime=new Date(System.currentTimeMillis());//更新时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
//    十秒倒计时
    public static void tendown()
    {
        int number=10;
        while (true)
        {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(number--);
            if(number&lt;=0)
            {
                break;
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程停止]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-ting-zhi/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-ting-zhi/">
        </link>
        <updated>2021-03-30T10:59:28.000Z</updated>
        <content type="html"><![CDATA[<p>测试stop<br>
//1.建议线程正常停止---&gt;利用次数,不建议死循环。<br>
//2.建议使用标志位---&gt;设置一个标志位<br>
//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法</p>
<pre><code>package com.deng.pojo1;

public class TestStop implements Runnable {
    private boolean flag=true;
    @Override
    public void run()
    {
        int i=1;
        while (flag)
        {
            System.out.println(&quot;线程继续运行：&quot;+i++);
        }
    }
    public void stop()
    {
        this.flag=false;
    }

    public static void main(String[] args) {
        TestStop testStop=new TestStop();
        new Thread(testStop).start();
        for (int i = 0; i &lt; 1000; i++) {
            if(i==900)
            {
                testStop.stop();
                System.out.println(&quot;线程该结束了&quot;);
            }
            else {
                System.out.println(&quot;main方法执行了：&quot;+i+&quot;次&quot;);
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>