<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2651560750.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-31T11:11:17.518Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2651560750.github.io"/>
    <link rel="self" href="https://2651560750.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://2651560750.github.io/images/avatar.png</logo>
    <icon>https://2651560750.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程同步机制（重点加难点）]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-tong-bu-ji-zhi-chong-dian-jia-nan-dian/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-tong-bu-ji-zhi-chong-dian-jia-nan-dian/">
        </link>
        <updated>2021-03-30T12:54:39.000Z</updated>
        <content type="html"><![CDATA[<p>package com.deng.pojo1;<br>
//守护线程随着用户线程的结束而结束<br>
public class TestDaemon {<br>
public static void main(String[] args) {<br>
God god=new God();<br>
You you=new You();<br>
Thread thread=new Thread(god);<br>
thread.setDaemon(true);<br>
thread.start();//上帝守护线程启动<br>
new Thread(you).start();//用户线程启动<br>
}<br>
}<br>
class You implements Runnable{</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 36500; i++) {
        System.out.println(&quot;祝你一生都活的开开心心&quot;);
    }
    System.out.println(&quot;========goodbye,this,world======&quot;);
}
</code></pre>
<p>}<br>
class God implements  Runnable{</p>
<pre><code>@Override
public void run() {
    while (true)
    {
        System.out.println(&quot;上帝一直守护着你&quot;);
    }
}
</code></pre>
<p>}<br>
<img src="https://2651560750.github.io/post-images/1617111080184.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之守护线程]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-shou-hu-xian-cheng/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-shou-hu-xian-cheng/">
        </link>
        <updated>2021-03-30T12:24:56.000Z</updated>
        <content type="html"><![CDATA[<p>#守护线程的定义<br>
线程分为用户线程和守护线程<br>
虚拟机必须确保用户线程执行完毕<br>
虚拟机不用等待守护线程执行完毕<br>
如,后台记录操作日志,监控内存,垃圾回收等待</p>
<pre><code>package com.deng.pojo1;
//守护线程随着用户线程的结束而结束
public class TestDaemon {
    public static void main(String[] args) {
        God god=new God();
        You you=new You();
        Thread thread=new Thread(god);
              thread.setDaemon(true);
              thread.start();//上帝守护线程启动
              new Thread(you).start();//用户线程启动
    }
}
class You implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i &lt; 36500; i++) {
            System.out.println(&quot;祝你一生都活的开开心心&quot;);
        }
        System.out.println(&quot;========goodbye,this,world======&quot;);
    }
}
class God implements  Runnable{

    @Override
    public void run() {
        while (true)
        {
            System.out.println(&quot;上帝一直守护着你&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程的优先级]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-de-you-xian-ji/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-de-you-xian-ji/">
        </link>
        <updated>2021-03-30T12:08:20.000Z</updated>
        <content type="html"><![CDATA[<p>#优先级的概念<br>
Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。<br>
线程的优先级用数字表示，范围从1~10.<br>
Thread.MIN_PRIORITY=1;<br>
Thread.MAX_PRIORITY = 10;Thread.NORM_PRIORITY = 5;使用以下方式改变或获取优先级<br>
getPriority() . setPriority(int xxx)<br>
#代码示范</p>
<pre><code>package com.deng.pojo1;

public class TestPriority {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());
        Mypriority mypriority=new Mypriority();
        Thread t1=new Thread(mypriority);
        Thread t2=new Thread(mypriority);
        Thread t3=new Thread(mypriority);
        Thread t4=new Thread(mypriority);
        Thread t5=new Thread(mypriority);
        t1.start();

        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        t4.setPriority(8);
        t4.start();

        t5.setPriority(Thread.MAX_PRIORITY);
        t5.start();

    }
}
class Mypriority implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之观测线程状态]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-guan-ce-xian-cheng-zhuang-tai/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-guan-ce-xian-cheng-zhuang-tai/">
        </link>
        <updated>2021-03-30T11:48:42.000Z</updated>
        <content type="html"><![CDATA[<p>#实现五种状态的代码</p>
<pre><code>package com.deng.pojo1;

public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread=new Thread(()-&gt;{
            for (int i = 0; i &lt; 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;////////&quot;);
        });
       Thread.State state=thread.getState();
        System.out.println(state);
        thread.start();
        state =thread.getState();
        System.out.println(state);
        while (state!=Thread.State.TERMINATED)
        {
            Thread.sleep(100);
            state=thread.getState();
            System.out.println(state);
        }
    }
}
</code></pre>
<p>#运行结果</p>
<pre><code>NEW
RUNNABLE
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
TIMED_WAITING
RUNNABLE
////////
TERMINATED
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之强制执行]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-qiang-zhi-zhi-xing/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-qiang-zhi-zhi-xing/">
        </link>
        <updated>2021-03-30T11:38:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code>package com.deng.pojo1;

public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.println(&quot;线程VIP来了&quot;+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin=new TestJoin();
        Thread thread=new Thread(testJoin);
        thread.start();
        for (int i = 0; i &lt; 500; i++) {
            if(i==200)
            {
                thread.join();
            }
            System.out.println(&quot;main方法执行&quot;+i);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程礼让]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-li-rang/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-li-rang/">
        </link>
        <updated>2021-03-30T11:22:29.000Z</updated>
        <content type="html"><![CDATA[<p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>
将线程从运行状态转为就绪状态<br>
让cpu重新调度，礼让不一定成功!看CPU心情</p>
<pre><code>package com.deng.pojo1;

public class TestYied {
    public static void main(String[] args) {
      Myyield myyield=new Myyield();
      new Thread(myyield,&quot;A&quot;).start();
      new Thread(myyield,&quot;B&quot;).start();
    }
}
class Myyield implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程休眠]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-xiu-mian/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-xiu-mian/">
        </link>
        <updated>2021-03-30T11:00:52.000Z</updated>
        <content type="html"><![CDATA[<p>#模仿网络延迟和获取当前时间</p>
<pre><code>package com.deng.pojo1;

import com.deng.pojo.TestThread5;
//模拟网络延迟：放大问题的发生性
public class TestSleep implements Runnable{
    private int tickeNums=10;
    @Override
    public void run()
    {
        while (true)
        {
            if (tickeNums&lt;=0)
            {
                break;
            }
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot;拿到了第&quot;+tickeNums--+&quot;张票&quot;);
        }
    }


    public static void main(String[] args) {
        TestThread5 t1=new TestThread5();
        new Thread(t1,&quot;邓贝&quot;).start();
        new Thread(t1,&quot;黄哲浩&quot;).start();
        new Thread(t1,&quot;岁东航&quot;).start();
    }
}
</code></pre>
<pre><code>package com.deng.pojo1;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TestSleep02 {
    public static void main(String[] args) {
//tendown();
//        打印系统当前时间
        Date starttime=new Date(System.currentTimeMillis());//获取当前时间
        while (true)
        {
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(starttime));
                starttime=new Date(System.currentTimeMillis());//更新时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
//    十秒倒计时
    public static void tendown()
    {
        int number=10;
        while (true)
        {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(number--);
            if(number&lt;=0)
            {
                break;
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习之线程停止]]></title>
        <id>https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-ting-zhi/</id>
        <link href="https://2651560750.github.io/post/duo-xian-cheng-xue-xi-zhi-xian-cheng-ting-zhi/">
        </link>
        <updated>2021-03-30T10:59:28.000Z</updated>
        <content type="html"><![CDATA[<p>测试stop<br>
//1.建议线程正常停止---&gt;利用次数,不建议死循环。<br>
//2.建议使用标志位---&gt;设置一个标志位<br>
//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法</p>
<pre><code>package com.deng.pojo1;

public class TestStop implements Runnable {
    private boolean flag=true;
    @Override
    public void run()
    {
        int i=1;
        while (flag)
        {
            System.out.println(&quot;线程继续运行：&quot;+i++);
        }
    }
    public void stop()
    {
        this.flag=false;
    }

    public static void main(String[] args) {
        TestStop testStop=new TestStop();
        new Thread(testStop).start();
        for (int i = 0; i &lt; 1000; i++) {
            if(i==900)
            {
                testStop.stop();
                System.out.println(&quot;线程该结束了&quot;);
            }
            else {
                System.out.println(&quot;main方法执行了：&quot;+i+&quot;次&quot;);
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库学习之事务（要么全部成功，要么全部失败）]]></title>
        <id>https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-shi-wu-yao-me-quan-bu-cheng-gong-yao-me-quan-bu-shi-bai/</id>
        <link href="https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-shi-wu-yao-me-quan-bu-cheng-gong-yao-me-quan-bu-shi-bai/">
        </link>
        <updated>2021-03-30T06:59:29.000Z</updated>
        <content type="html"><![CDATA[<p>#ACID</p>
<ol>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>
#手动事务<br>
—-手动处理事务<br>
SETautocommit = o--关闭自动提交<br>
-—事务开启<br>
START TRANSACTION--标记一个事务的开始，从这个之后的 sql都在同一个事务内<br>
INSERT xX<br>
INSERTxz<br>
-―提交:持久化(成功!)<br>
COMMIT<br>
--回滚:回到的原来的样子(失败!)<br>
ROLLBACK<br>
--事务结束<br>
SETautocommit =l --开启自动提交<br>
—-了解<br>
SAVEPOINT 保存点名--设置一个事务的保存点<br>
ROLLBACK TO SAVEPOINT 保存点名--回滚到保存点<br>
#模拟场景</li>
</ol>
<pre><code>CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci
USE shop
CREATE TABLE account(
`id` INT(3) NOT NULL AUTO_INCREMENT,
`name` VARCHAR(30) NOT NULL,
`money` DECIMAL(9,2) NOT NULL,
PRIMARY KEY(`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8
INSERT INTO account(name,money)
VALUES('A','2000.00'),('B','10000.00')
SET autocommit=0;
START TRANSACTION
UPDATE account SET money=money+500 WHERE name='A'
UPDATE account SET money=money-500 WHERE name='B'
COMMIT;
ROLLBACK;
SET autocommit=1;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库学习之聚合函数和分组查询（扩展知识：加密）]]></title>
        <id>https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-ju-he-han-shu-he-fen-zu-cha-xun/</id>
        <link href="https://2651560750.github.io/post/shu-ju-ku-xue-xi-zhi-ju-he-han-shu-he-fen-zu-cha-xun/">
        </link>
        <updated>2021-03-30T06:33:43.000Z</updated>
        <content type="html"><![CDATA[<p>#聚合函数<br>
都能够统计表中的数据(想查询一个表中有多少个记录，就使用这个count() )</p>
<pre><code>SELECT COUNT (`BornDate`) FROM student; -- Count (字段)，会忽略所有的null值
SELECT COUNT (*） FROM student; -- Count(*)，不会忽略null值，本质计算行数
SELECT COUNT (1)FROM result; -- Count(1)，不会忽略忽略所有的 null值本质计算行数
</code></pre>
<pre><code>SELECT SUM (`StudentResult`)AS总和 FROM result
SELECT AVG(StudentResult`)AS 平均分FROM result
SELECT MAX(StudentResult`) AS最高分 FROM result
SELECT MIN(StudentResult`) AS 最低分 FROM result
</code></pre>
<p>#分组查询<br>
--查询不同课程的平均分，最高分，最低分，平均分大于80-―核心:(根据不同的课程分组)</p>
<pre><code>SELECT SubjectName，AVG (studentResult) As 平均分, NaX (StudentResult) AS 最高分, MrnN (StudentResult) slFROM result r
INNER JOIN`subject sub
ONr. `SubjectNo=sub. &quot; SubjectNo
GROUP BY r.SubjectNo --通过什么字段来分组HAVING 平均分&gt;80
</code></pre>
<p>#加密<br>
-―明文密码<br>
<code>INSERT INTO testmd5 VAEUES (1,' zhangsan','123456'),(2,'lisi','123456'), (3', ' wangwu' , '123456')</code><br>
--加密<br>
<code>UPDATE testmd5 SET pwd=MD5(pwd) WHERE id= 1</code><br>
<code>UPDATE testmd5 SET pwd=MD5 (pwd) --加密全部的密码</code><br>
-―插入的时候加密<br>
<code>INSERT INTO testmd5 VALUES (4, 'xiaoming' ,MD5('123456'))</code><br>
--如何校验:将用户传递进来的密码，进行md5加密，然后比对加密后的值SELECT * FROM testmd5 <code>WHERE ‘name '='xiaoming' AND pwd=MD5 ('123456')</code></p>
]]></content>
    </entry>
</feed>