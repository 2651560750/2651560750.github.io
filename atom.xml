<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2651560750.github.io</id>
    <title>Gridea</title>
    <updated>2021-03-24T13:50:19.276Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2651560750.github.io"/>
    <link rel="self" href="https://2651560750.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://2651560750.github.io/images/avatar.png</logo>
    <icon>https://2651560750.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[声明事务]]></title>
        <id>https://2651560750.github.io/post/sheng-ming-shi-wu/</id>
        <link href="https://2651560750.github.io/post/sheng-ming-shi-wu/">
        </link>
        <updated>2021-03-24T11:00:45.000Z</updated>
        <content type="html"><![CDATA[<p>13、声明式事务1、回顾事务<br>
1.把一组业务当成一个业务来做;要么都成功，要么都失败!<br>
2.事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎!<br>
3.确保完整性和一致性;<br>
I<br>
事务ACID原则:<br>
1.原子性。<br>
2.一致性<br>
3.隔离性<br>
多个业务可能操作同一个资源，防止数据损坏·<br>
4.持久性<br>
事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Spring实现AOP]]></title>
        <id>https://2651560750.github.io/post/shi-yong-spring-shi-xian-aop/</id>
        <link href="https://2651560750.github.io/post/shi-yong-spring-shi-xian-aop/">
        </link>
        <updated>2021-03-24T08:02:31.000Z</updated>
        <content type="html"><![CDATA[<p>使用AOP，需要导入一个依赖包</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.6&lt;/version&gt;
        &lt;/dependency&gt;
        ```
        方式一：使用Spring的API接口
        方式二：自定义来实现AOP
        方式三：使用注解实现AOP
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态代理]]></title>
        <id>https://2651560750.github.io/post/dong-tai-dai-li/</id>
        <link href="https://2651560750.github.io/post/dong-tai-dai-li/">
        </link>
        <updated>2021-03-23T13:06:03.000Z</updated>
        <content type="html"><![CDATA[<p>动态代理和静态代理角色一样<br>
动态代理的代理类是动态生成的，不是我们直接写好的!<br>
动态代理分为两大类:基于接口的动态代理，基于类的动态代理<br>
。基于接口---JDK动态代理<br>
。基于类: cglib<br>
o java字节码实现 : javasist</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态代理]]></title>
        <id>https://2651560750.github.io/post/jing-tai-dai-li/</id>
        <link href="https://2651560750.github.io/post/jing-tai-dai-li/">
        </link>
        <updated>2021-03-22T02:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>角色分析：<br>
抽象角色：一般用接口或抽象类来解决<br>
真实角色：被代理的角色<br>
代理角色：代理真是角色，代理后，一般会实现一些附属操作<br>
客户：访问代理对象的人<br>
代理模式的好处：<br>
*可以使真是角色的操作更加纯粹！不用去管理其他的操作。<br>
*公共业务也就交给了角色，实现了业务的分工<br>
*公共业务拓展的时候，方便集中管理<br>
缺点：一个真是角色就会产生一个代理角色；代码量会翻倍，开发效率会变低；<br>
过程：<br>
1.接口：<br>
package com.deng.damo01;</p>
<p>public interface Rent {<br>
public void rent();<br>
}<br>
2.真实角色<br>
package com.deng.damo01;</p>
<p>public class Host implements Rent{<br>
public void rent(){<br>
System.out.println(&quot;房东要出租房子&quot;);<br>
}<br>
}<br>
3.代理角色<br>
package com.deng.damo01;</p>
<p>public class Proxy implements Rent{<br>
private Host host;</p>
<pre><code>public Proxy() {

}

public Proxy(Host host) {
    this.host = host;
}
</code></pre>
<p>public void rent(){<br>
host.rent();<br>
lookhouse();<br>
fare();<br>
hetong();<br>
}<br>
public void lookhouse(){<br>
System.out.println(&quot;看房子&quot;);<br>
}<br>
public void fare(){<br>
System.out.println(&quot;中介收取中介费&quot;);<br>
}<br>
public void hetong(){<br>
System.out.println(&quot;签合同&quot;);<br>
}<br>
}<br>
4.客户访问代理角色<br>
package com.deng.damo01;</p>
<p>public class Client {<br>
public static void main(String[] args) {<br>
Host host=new Host();<br>
Proxy proxy=new Proxy(host);<br>
proxy.rent();<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用javaconfig实现配置]]></title>
        <id>https://2651560750.github.io/post/shi-yong-javaconfig-shi-xian-pei-zhi/</id>
        <link href="https://2651560750.github.io/post/shi-yong-javaconfig-shi-xian-pei-zhi/">
        </link>
        <updated>2021-03-22T02:10:22.000Z</updated>
        <content type="html"><![CDATA[<p>1.实现类<br>
package com.deng.pojo;</p>
<p>import org.springframework.beans.factory.annotation.Value;<br>
import org.springframework.stereotype.Component;<br>
//注解的意思是这个类被Spring接管了，装在了容器里面<br>
@Component<br>
public class User {<br>
private String name;</p>
<pre><code>public String getName() {
    return name;
}
</code></pre>
<p>@Value(&quot;beiye&quot;)//属性注入值<br>
public void setName(String name) {<br>
this.name = name;<br>
}</p>
<pre><code>@Override
public String toString() {
    return &quot;User{&quot; +
            &quot;name='&quot; + name + '\'' +
            '}';
}
</code></pre>
<p>}<br>
2.配置类<br>
package com.deng.config;</p>
<p>import com.deng.pojo.User;<br>
import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>@Configuration//他也会被容器托管，注册到容器之中，他本身也是一个@Component类<br>
//@Configuration 他就是一个配置类，和之前的xml文件一样<br>
public class dengconfig {<br>
//注册一个bean，就相当于之前写的一个bean标签<br>
//这个方法名，就相当于bean标签中的id属性<br>
//这个方法的返回值，就相当于bean标签中的class属性<br>
@Bean<br>
public User getuser() {<br>
return new User();//返回当前对象<br>
}<br>
}<br>
3.测试类<br>
import com.deng.config.dengconfig;<br>
import com.deng.pojo.User;<br>
import org.springframework.context.ApplicationContext;<br>
import org.springframework.context.annotation.AnnotationConfigApplicationContext;</p>
<p>public class MyTest {<br>
public static void main(String[] args) {<br>
//如果使用配置类去完成，只能通过ApplicationContext context=new AnnotationConfigApplicationContext(dengconfig.class);<br>
//获取上下文的容器<br>
ApplicationContext context=new AnnotationConfigApplicationContext(dengconfig.class);<br>
User user=(User)context.getBean(&quot;getuser&quot;);<br>
System.out.println( user.getName());<br>
}<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring注解开发]]></title>
        <id>https://2651560750.github.io/post/Spring注解开发/</id>
        <link href="https://2651560750.github.io/post/Spring注解开发/">
        </link>
        <updated>2021-03-21T08:14:23.000Z</updated>
        <content type="html"><![CDATA[<p>1.环境配置</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    https://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    https://www.springframework.org/schema/aop/spring-aop.xsd"><br>
<a href="context:annotation-config/">context:annotation-config/</a><br>
&lt;context:component-scan base-package=&quot;com.deng.dao&quot;/&gt;<br>
</beans><br>
2.属性该如何注入<br>
package com.deng.dao;<br>
import org.springframework.beans.factory.annotation.Value;<br>
import org.springframework.stereotype.Component;<br>
//@Component 组件<br>
//等价于    <bean id="user" class="com.deng.dao.User"/><br>
@Component<br>
public class User {<br>
// @Value  相当于 <property name="name" value="dengbei"/><br>
@Value(&quot;dengbei&quot;)<br>
public String name;<br>
}<br>
3.衍生的注解<br>
@Component 有几个衍生的注解，在Web开发中，一般分为三层</p>
<ul>
<li>Dao【@Repository】</li>
<li>service 【@Service】</li>
<li>contoller【@Controller】<br>
这四个注解功能一样，只是用于不同层次的表示而已<br>
4.作用域<br>
@Component<br>
@Scope(&quot;singleton&quot;)<br>
public class User {<br>
// @Value  相当于 <property name="name" value="dengbei"/><br>
@Value(&quot;dengbei&quot;)<br>
public String name;<br>
}</li>
</ul>
<ol start="5">
<li>小结<br>
xml更加万能，适用于任何场所！维护相对简单。<br>
注解不是自己的类用不了，维护相对复杂。<br>
xml和注解的最佳实践是：<br>
xml用来管理bean，注解只负责属性的注入。<br>
注意：在使用注解时一定要开启注解的支持。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用注解实现自动装配]]></title>
        <id>https://2651560750.github.io/post/shi-yong-zhu-jie-shi-xian-zi-dong-zhuang-pei/</id>
        <link href="https://2651560750.github.io/post/shi-yong-zhu-jie-shi-xian-zi-dong-zhuang-pei/">
        </link>
        <updated>2021-03-21T07:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>使用注解注意事项：<br>
1.导入约束      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>
2.配置注解支持    <a href="context:annotation-config/">context:annotation-config/</a></p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
              xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    https://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    https://www.springframework.org/schema/aop/spring-aop.xsd"><br>
<a href="context:annotation-config/">context:annotation-config/</a><br>
</beans><br>
@Autowired<br>
1.直接在属性上使用即可，也可以用在set方法上<br>
2.如果 @Autowired的required定义为false表示这个对象可以为空，否则就不可以为空<br>
public class People {<br>
@Autowired<br>
private Dog dog;<br>
@Autowired(required = false)<br>
private Cat cat;<br>
private String name;<br>
3.如果 @Autowired自动装配环境比较复杂，自动装配无法通过一个注解 @Autowired完成的时候<br>
我们可以通过@Qualifier(value = &quot;id名&quot;)去配置  @Autowired的使用，指定唯一的bean的对象注入！<br>
public class People {<br>
@Autowired<br>
@Qualifier(value = &quot;dog01&quot;)<br>
private Dog dog;<br>
@Autowired<br>
@Qualifier(value = &quot;cat02&quot;)<br>
private Cat cat;<br>
private String name;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bean的自动装配]]></title>
        <id>https://2651560750.github.io/post/bean的自动装配/</id>
        <link href="https://2651560750.github.io/post/bean的自动装配/">
        </link>
        <updated>2021-03-21T06:37:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code>自动装配是Spring满足bean以来的一种方式
Spring会自动寻找上下文，并自定给出bean装配属性
在Spring中有三种装配的方式
1.在xml中显示的装配
2.在java中显示的装配
3.隐式的自动装配bean
</code></pre>
<p>一： 环境搭建：<br>
一个人有两只宠物</p>
<ol>
<li>ByNmae自动搭配</li>
</ol>
  <!--   ByName自动装配，会在容器上下文中查找，和自己对象set方法后面对应的bean的id的值-->
   <bean id="dog" class="com.deng.pojo.Dog"/>
    <bean id="cat" class="com.deng.pojo.Cat"/>
    <bean id="people" class="com.deng.pojo.People" autowire="byName">
        <property name="name" value="黄皮耗子"/>
    </bean>
1. ByType 自动装配
       <!--   ByName自动装配，会在容器上下文中查找，和自己对象属性类型相同的bean-->
   <bean  class="com.deng.pojo.Dog"/>
    <bean  class="com.deng.pojo.Cat"/>
    <bean id="people" class="com.deng.pojo.People" autowire="byType">
        <property name="name" value="黄皮耗子"/>
    </bean>
总结：  <!--   ByName自动装配，需要保证bean的id的唯一性，并且这个bean要和自动注入属性的set方法的值一致>
<!--   ByType自动装配，需要保证bean的class的唯一性，并且这个bean要和自动注入属性的属性类型一致>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bean的作用域]]></title>
        <id>https://2651560750.github.io/post/bean-de-zuo-yong-yu/</id>
        <link href="https://2651560750.github.io/post/bean-de-zuo-yong-yu/">
        </link>
        <updated>2021-03-21T06:30:43.000Z</updated>
        <content type="html"><![CDATA[<p>1.单例模式：（Spring默认机制）每次去容器中get的时候都只是同一个对象<br>
<bean id="user2" class="com.deng.pojo.User" c:name="黄皮耗子" c:age="3" scope="singleton"/><br>
2. 原型模式：每次去容器中get的时候都会产生一个新的对象<br>
<bean id="user2" class="com.deng.pojo.User" c:name="黄皮耗子" c:age="3" scope="prototype"/><br>
3. 其他模式只有在Web开发中才会用到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DI依赖注入环境]]></title>
        <id>https://2651560750.github.io/post/di-yi-lai-zhu-ru-huan-jing/</id>
        <link href="https://2651560750.github.io/post/di-yi-lai-zhu-ru-huan-jing/">
        </link>
        <updated>2021-03-20T11:51:11.000Z</updated>
        <content type="html"><![CDATA[<p>1.构造器注入</p>
<p>2.set方式注入【重点】<br>
依赖：bean对象的创建依赖于容器！<br>
注入：bean对象中的所有属性，由容器来注入！<br>
环境搭建：<br>
1.复杂类型<br>
package com.deng.pojo;</p>
<p>public class Address {<br>
private String address;</p>
<pre><code>public String getAddress() {
    return address;
}

public void setAddress(String address) {
    this.address = address;
}
</code></pre>
<p>}</p>
<p>2.真实测试对象<br>
package com.deng.pojo;</p>
<p>import java.util.*;</p>
<p>public class Student {<br>
private String name;<br>
private Address address;<br>
private String[] books;<br>
private List<String> hobby;<br>
private Map&lt;String,String&gt; card;<br>
private Set<String> games;<br>
private Properties info;<br>
private  String wife;</p>
<pre><code>public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public Address getAddress() {
    return address;
}

public void setAddress(Address address) {
    this.address = address;
}

public String[] getBooks() {
    return books;
}

public void setBooks(String[] books) {
    this.books = books;
}

public List&lt;String&gt; getHobby() {
    return hobby;
}

public void setHobby(List&lt;String&gt; hobby) {
    this.hobby = hobby;
}

public Map&lt;String, String&gt; getCard() {
    return card;
}

public void setCard(Map&lt;String, String&gt; card) {
    this.card = card;
}

public Set&lt;String&gt; getGames() {
    return games;
}

public void setGames(Set&lt;String&gt; games) {
    this.games = games;
}

public Properties getInfo() {
    return info;
}

public void setInfo(Properties info) {
    this.info = info;
}

public String getWife() {
    return wife;
}

public void setWife(String wife) {
    this.wife = wife;
}

@Override
public String toString() {
    return &quot;Student{&quot; +
            &quot;name='&quot; + name + '\'' +
            &quot;, address=&quot; + address +
            &quot;, books=&quot; + Arrays.toString(books) +
            &quot;, hobby=&quot; + hobby +
            &quot;, card=&quot; + card +
            &quot;, games=&quot; + games +
            &quot;, info=&quot; + info +
            &quot;, wife='&quot; + wife + '\'' +
            '}';
}
</code></pre>
<p>}<br>
3.<?xml version="1.0" encoding="UTF-8"?><br>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"></p>
<pre><code>&lt;bean id=&quot;address&quot; class=&quot;com.deng.pojo.Address&quot;/&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.deng.pojo.Student&quot;&gt;
    &lt;!--    第一种，普通类，直接注入value--&gt;
    &lt;property name=&quot;name&quot; value=&quot;贝爷&quot;/&gt;
    &lt;!--    第二种，bean类，注入ref--&gt;
    &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
    &lt;!--    第三种，数组--&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt; 红楼梦&lt;/value&gt;
            &lt;value&gt; 水浒传&lt;/value&gt;
            &lt;value&gt; 平凡的世界&lt;/value&gt;
            &lt;value&gt;明朝那些事儿&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
       &lt;!-- 第四种，list--&gt;
    &lt;property name=&quot;hobby&quot;&gt;
        &lt;list&gt;
            &lt;value&gt; 听歌&lt;/value&gt;
            &lt;value&gt; 打游戏&lt;/value&gt;
            &lt;value&gt; 敲代码&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
       &lt;!--第五种，Map--&gt;
    &lt;property name=&quot;card&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;身份证&quot; value=&quot;362501200105266618&quot;/&gt;
            &lt;entry key=&quot;银行卡&quot; value=&quot;200165165151651065&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
     &lt;!--Set--&gt;
    &lt;property name=&quot;games&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;LOL&lt;/value&gt;
            &lt;value&gt;COC&lt;/value&gt;
            &lt;value&gt;BOB&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;!--空指针--&gt;
   &lt;!--&lt;property name=&quot;wife&quot; value=&quot;&quot;/&gt;空值--&gt;
    &lt;property name=&quot;wife&quot;&gt;
        &lt;null/&gt;&lt;!--空指针--&gt;
    &lt;/property&gt;
    &lt;property name=&quot;info&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;学号&quot;&gt;201908130310&lt;/prop&gt;
            &lt;prop key=&quot;性别&quot;&gt;男性&lt;/prop&gt;
            &lt;prop key=&quot;班级&quot;&gt; 软件1903班&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</beans>
<p>3.测试结果<br>
import com.deng.pojo.Student;<br>
import org.springframework.context.support.ClassPathXmlApplicationContext;</p>
<p>public class MyTrxt {<br>
public static void main(String[] args) {<br>
ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);<br>
Student student=(Student) context.getBean(&quot;student&quot;);<br>
System.out.println(student.toString());<br>
}<br>
}<br>
//    Student{<br>
//    name='贝爷',<br>
//    address=Address{address='长沙'},<br>
//    books=[ 红楼梦,  水浒传,  平凡的世界, 明朝那些事儿],<br>
//    hobby=[ 听歌,  打游戏,  敲代码],<br>
//    card={身份证=362501200105266618, 银行卡=200165165151651065},<br>
//    games=[LOL, COC, BOB],<br>
//    info={学号=201908130310, 性别=男性, 班级=软件1903班},<br>
//    wife='null'<br>
//    }<br>
4.拓展方式注入<br>
可以运用p/c命名空间进行注入</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"><br>
<!-- p命名空间注入，可以直接注入属性值,proprety--><br>
<bean id="user" class="com.deng.pojo.User" p:name="贝爷" p:age="21"/><br>
<!--c命名空间注入，通过构造器注入，construct-args--><br>
<bean id="user2" class="com.deng.pojo.User" c:name="黄皮耗子" c:age="3"/><br>
</beans><br>
测试：<br>
@Test<br>
public void text2(){<br>
ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext(&quot;Userbeans.xml&quot;);<br>
User user=(User) context.getBean(&quot;user2&quot;);<br>
System.out.println(user);<br>
}<br>
注意：<br>
要导入<br>
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;<br>
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br>
这两个约束。</p>
]]></content>
    </entry>
</feed>